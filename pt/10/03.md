---
title: Compilando o código fonte
actions: ['verificarResposta', 'dicas']
requireLogin: true
material:
  terminal:
    help:
      Você provavelmente deve executar `truffle compile`.
    commands:
        "truffle compile":
            hint: truffle compile
            output: |
                Compiling ./contracts/Migrations.sol...
                Compiling ./contracts/CryptoZombies.sol...
                Compiling ./contracts/erc721.sol...
                Compiling ./contracts/ownable.sol...
                Compiling ./contracts/safemath.sol...
                Compiling ./contracts/zombieattack.sol...
                Compiling ./contracts/zombiefactory.sol...
                Compiling ./contracts/zombiefeeding.sol...
                Compiling ./contracts/zombiehelper.sol...
                Compiling ./contracts/zombieownership.sol...
                Writing artifacts to ./build/contracts
---

Parabéns! Agora que colocamos a estrutura do projeto no lugar e configuramos `truffle-hdwallet-provider`, vamos compilar nossos contratos.

Por que precisamos compilar, você pergunta?

A _Ethereum Virtual Machine_ não consegue entender diretamente o código-fonte do Solidity enquanto o escrevemos. Portanto, precisamos executar um compilador que "traduzirá" nosso contrato inteligente em **_bytecode_** legível por máquina. A máquina virtual então executa o bytecode e conclui as ações necessárias para nosso contrato inteligente.

Curioso sobre como é o bytecode? Vamos dar uma olhada:

```
"0x60806040526010600155600154600a0a6002556201518060035566038d7ea4c6800060085560006009556046600a55336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1..."
```

Como você pode ver, um humano tem a mesma probabilidade de conseguir ler bytecode que um zumbi de verdade!

## Usando o compilador Solidity

Agora que estamos falando sobre o compilador Solidity, devemos mencionar que os desenvolvedores conseguiram incluir alguns recursos bacanas.

Vamos fingir que queremos modificar a definição da função `add` incluída em `SafeMath`:

```
function add(uint16 a, uint16 b) internal returns (uint16) {
    uint16 c = a + b;
    assert(c >= a);
    return c;
}
```

Se formos compilar esta função, o compilador Solidity lançará um **_warning_**:

```
safemath.sol:110:11: Warning: Function state mutability can be restricted to pure
          function add(uint16 a, uint16 b) internal returns (uint16) {
          ^ (Relevant source part starts here and spans across multiple lines).
```

O que o compilador está tentando dizer é que nossa função não lê ou escreve de/para o blockchain e que devemos usar o modificador `pure`.

Por que isso é importante?

Bem, tornar uma função `pure` ou `view` nos economiza gás. Como essas funções não vão modificar o estado do blockchain, não há necessidade de mineradores para executá-las. Para colocar em poucas palavras, as funções `pure` e `view` podem ser `chamadas` de graça.


## CryptoZombies- O Jogo

Lembre-se, nós incorporamos nossa lógica em um contrato inteligente chamado `ZombieOwnership.sol`.

Hmmm... não é um ótimo nome para um jogo.

Felizmente, isso não é um problema. Podemos usar herança para criar um contrato inteligente com as mesmas ações e recursos com qualquer nome que escolhermos.

Vamos criar um novo contrato inteligente chamado `CryptoZombies` que herda de `ZombieOwnership.sol`:

```solidity
pragma solidity ^0.4.24;

import "./zombieownership.sol";

contract CryptoZombies is ZombieOwnership
    {

    }
```

Em seguida, copiamos todos os nossos contratos inteligentes para a pasta `./contracts`. Agora a estrutura do projeto deve ficar assim:

```
.
├── contracts
    ├── Migrations.sol
    ├── CryptoZombies.sol
    ├── erc721.sol
    ├── ownable.sol
    ├── safemath.sol
    ├── zombieattack.sol
    ├── zombiefactory.sol
    ├── zombiefeeding.sol
    ├── zombiehelper.sol
    ├── zombieownership.sol
├── migrations
└── test
```

Tudo está configurado corretamente. Vamos compilar nosso projeto.

# Vamos testar

1. Execute `truffle compile`. Este comando deve criar os artefatos de build e colocá-los no diretório `./build/contracts`.

 >Nota: Os artefatos de construção são compostos pelas versões "bytecode" dos contratos inteligentes, ABIs e alguns dados internos que **Truffle** está usando para implantar corretamente o código. Evite editar esses arquivos, ou **Truffle** pode parar de funcionar corretamente.
